#闭包的理解  

1.当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们.
for(int i=0;i<10;i++)当for循环结束之后局部变量i就会丢失。  
但是在闭包中  
function aa(){  
int i=0;  
function bbb(){  

a++;  
alert(a)  

}  
return bbb;
}  
var result=aa();  

result();//1  

result();//2  
aa中的局部变量i在aa函数之行结束之后不会丢失，因为bbb（）函数需要它们，当bbb（）函数返回出到全局的时候形成闭包，保存了aa中的局部变量i，并且可以在全局修改。  

  
  
2.当全局有变量i时候，局部也有i时候，局部调用则是调用局部的i，全局就是调用全局的i，在c＋＋中可以堪称就近原则。  
# 回收机制  
如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。
#应用场景  
保护函数内的变量安全。以最开始的例子为例，函数a中i只有函数b才能访问，而无法通过其他途径访问到，因此保护了i的安全性。
 
在内存中维持一个变量。依然如前例，由于闭包，函数a中i的一直存在于内存中，因此每次执行c()，都会给i自加1。
通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）
私有属性和方法在Constructor外是无法被访问的